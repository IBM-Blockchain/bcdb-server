"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3138],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>m});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),s=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),u=s(r),p=n,m=u["".concat(l,".").concat(p)]||u[p]||h[p]||o;return r?a.createElement(m,i(i({ref:t},d),{},{components:r})):a.createElement(m,i({ref:t},d))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[u]="string"==typeof e?e:n,i[1]=c;for(var s=2;s<o;s++)i[s]=r[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}p.displayName="MDXCreateElement"},7853:(e,t,r)=>{r.r(t),r.d(t,{contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var a=r(7462),n=(r(7294),r(3905));const o={id:"block-structure",title:"Block Structure"},i=void 0,c={unversionedId:"architecture-and-design/block-structure",id:"architecture-and-design/block-structure",isDocsHomePage:!1,title:"Block Structure",description:"Block header data",source:"@site/docs/architecture-and-design/block-structure.md",sourceDirName:"architecture-and-design",slug:"/architecture-and-design/block-structure",permalink:"/orion-server/docs/architecture-and-design/block-structure",tags:[],version:"current",frontMatter:{id:"block-structure",title:"Block Structure"},sidebar:"Documentation",previous:{title:"Query Flow",permalink:"/orion-server/docs/architecture-and-design/query-flow"},next:{title:"Transaction Structure",permalink:"/orion-server/docs/architecture-and-design/transactions-structure"}},l=[{value:"Block header data",id:"block-header-data",children:[],level:3}],s={toc:l};function d(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,a.Z)({},s,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h3",{id:"block-header-data"},"Block header data"),(0,n.kt)("p",null,"A block is a collection of ordered transactions in a blockchain database. The header object within a block holds the block number, the root hash of the transaction merkle tree, the root hash of the state merkle tree, and the validation information. Except for the transactions themselves, the rest of the data is stored in the block header."),(0,n.kt)("p",null,"As mentioned above, the block header contains all the data required to prove the existence of a transaction and/or specific state at block time, in addition to the ledger connectivity (block existence) proofs."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Block number"),(0,n.kt)("li",{parentName:"ul"},"List of hashes (pointers) in the ledger skip chain; for a full explanation, see ",(0,n.kt)("a",{parentName:"li",href:"block-skip-chain"},"here")),(0,n.kt)("li",{parentName:"ul"},"Two merkle tree roots:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Transaction merkle tree root - for more explanation about non-repudiation and immutability proofs, see ",(0,n.kt)("a",{parentName:"li",href:"tx-merkle-tree"},"here")),(0,n.kt)("li",{parentName:"ul"},"DB state merkle-patricia trie root - ethereum style; for full trie explanation, see ",(0,n.kt)("a",{parentName:"li",href:"state-merkle-patricia-tree"},"here")))),(0,n.kt)("li",{parentName:"ul"},"Validation info for all block transactions.")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-protobuf"},"// BlockHeaderBase holds the block metadata and the chain information\n// that computed before transaction validation\nmessage BlockHeaderBase {\n  uint64 number = 1;\n  // Hash of (number - 1) BlockHeaderBase\n  bytes previous_base_header_hash = 2;\n  // Hash of BlockHeader of last block already committed to ledger\n  bytes last_committed_block_hash = 3;\n  // Number of last block already committed to ledger\n  uint64 last_committed_block_num = 4;\n}\n\n// BlockHeader holds, in addition to base header, rest of chain information that computed after transactions validation, \n// including state and transaction merkle trees roots, skip-chain hashes and transaction validation info\nmessage BlockHeader {\n  BlockHeaderBase base_header = 1;\n  // Skip chain hashed, based of BlockHeader hashed of blocks connected in blocks skip list\n  repeated bytes skipchain_hashes = 2;\n  // Root of Merkle tree that contains all transactions, including validation data\n  bytes tx_merkle_tree_root_hash = 3;\n  // Root hash of system wide state merkle-particia tree\n  bytes state_merkle_tree_root_hash = 4;\n  // Validation info for transactions in block.\n  repeated ValidationInfo validation_info = 5;\n}\n")))}d.isMDXComponent=!0}}]);