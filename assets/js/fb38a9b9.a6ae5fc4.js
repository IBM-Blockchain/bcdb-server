"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4307],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>k});var r=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,o=function(e,t){if(null==e)return{};var a,r,o={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var a=e.components,o=e.mdxType,n=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(a),f=o,k=d["".concat(s,".").concat(f)]||d[f]||h[f]||n;return a?r.createElement(k,i(i({ref:t},p),{},{components:a})):r.createElement(k,i({ref:t},p))}));function k(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var n=a.length,i=new Array(n);i[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<n;c++)i[c]=a[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}f.displayName="MDXCreateElement"},2163:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>i,default:()=>p,frontMatter:()=>n,metadata:()=>l,toc:()=>s});var r=a(7462),o=(a(7294),a(3905));const n={id:"proofs",title:"Ledger Data and Cryptographical Proofs"},i=void 0,l={unversionedId:"getting-started/proofs-and-verification/proofs",id:"getting-started/proofs-and-verification/proofs",isDocsHomePage:!1,title:"Ledger Data and Cryptographical Proofs",description:"Ledger Data and Cryptographical Proofs",source:"@site/docs/getting-started/proofs-and-verification/proofs.md",sourceDirName:"getting-started/proofs-and-verification",slug:"/getting-started/proofs-and-verification/proofs",permalink:"/orion-server/docs/getting-started/proofs-and-verification/proofs",tags:[],version:"current",frontMatter:{id:"proofs",title:"Ledger Data and Cryptographical Proofs"},sidebar:"Documentation",previous:{title:"Query a Transaction Receipt",permalink:"/orion-server/docs/getting-started/queries/curl/transaction-receipt"},next:{title:"Proof of Existence of a State/Data",permalink:"/orion-server/docs/getting-started/proofs-and-verification/gosdk/state"}},s=[{value:"Ledger Data and Cryptographical Proofs",id:"ledger-data-and-cryptographical-proofs",children:[{value:"Detailed proofs",id:"detailed-proofs",children:[],level:3},{value:"Proofs",id:"proofs",children:[{value:"Ledger connectivity proof",id:"ledger-connectivity-proof",children:[],level:4},{value:"Transaction existence proof",id:"transaction-existence-proof",children:[],level:4},{value:"State proof",id:"state-proof",children:[],level:4}],level:3}],level:2}],c={toc:s};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"ledger-data-and-cryptographical-proofs"},"Ledger Data and Cryptographical Proofs"),(0,o.kt)("p",null,"The ledger API gives the user access to the data stored in Orion ledger and is used to prove data integrity and provide tamper resistance and non-repudiation.\nFor more information about data structures exposed by the ledger, see ",(0,o.kt)("a",{parentName:"p",href:"../../architecture-and-design/block-skip-chain"},"block skip chain"),", ",(0,o.kt)("a",{parentName:"p",href:"../../architecture-and-design/tx-merkle-tree"},"Transactions merkle tree"),", and ",(0,o.kt)("a",{parentName:"p",href:"../../architecture-and-design/state-merkle-patricia-tree"},"state trie"),"."),(0,o.kt)("p",null,"The ledger API give users detailed access to ledger data and integrity proofs, including:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"block header data"),(0,o.kt)("li",{parentName:"ul"},"proof of transaction existence in block "),(0,o.kt)("li",{parentName:"ul"},"proof of block(s) existence in ledger "),(0,o.kt)("li",{parentName:"ul"},"proof of specific db ",(0,o.kt)("inlineCode",{parentName:"li"},"key->value")," existence at specific (block) time "),(0,o.kt)("li",{parentName:"ul"},"receipt for specific tx")),(0,o.kt)("p",null,"There are multiple ways to access ledger data, including proofs. First, there are multiple SDKs (including GO, for details see ",(0,o.kt)("a",{parentName:"p",href:"gosdk/ledger"},"here"),")\nand the REST API that can expose access to the server. For details, see ",(0,o.kt)("a",{parentName:"p",href:"curl/ledger"},"here"),"."),(0,o.kt)("p",null,"Based on provenance and ledger APIs, we can check:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"ledger integrity, by accessing block headers and validating the consistency of the ledger skip list"),(0,o.kt)("li",{parentName:"ul"},"transaction existence proof, composed of the Merkle tree path to the transaction in the block and the block existence proof: ",(0,o.kt)("inlineCode",{parentName:"li"},"GetTransactionProof()")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"GetLedgerPath()")),(0,o.kt)("li",{parentName:"ul"},"block existence proof, from TxReceipt or by accessing block headers and validating the consistency of the ledger skip list"),(0,o.kt)("li",{parentName:"ul"},"proof of active and past states, by ",(0,o.kt)("inlineCode",{parentName:"li"},"GetStateProof()")," proving existence of all state changes")),(0,o.kt)("h3",{id:"detailed-proofs"},"Detailed proofs"),(0,o.kt)("p",null,"The block proof contains a connected list of blocks from the end block to the start block."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},"message GetLedgerPathResponse {\n  ResponseHeader header = 1;\n  repeated BlockHeader block_headers = 2;\n}\n")),(0,o.kt)("p",null,"The transaction proof contains the path in the Merkle tree in the block to the root."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},"message GetTxProofResponse {\n  ResponseHeader header = 1;\n  repeated bytes hashes = 2;\n}\n")),(0,o.kt)("p",null,"The state proof contains the path in the block Merkle-Patricia trie from the leaf (key,value) to the root."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},"message GetDataProofResponse {\n  ResponseHeader header = 1;\n  repeated MPTrieProofElement path = 2;\n}\n\nmessage MPTrieProofElement {\n  repeated bytes hashes = 1;\n}\n")),(0,o.kt)("h3",{id:"proofs"},"Proofs"),(0,o.kt)("h4",{id:"ledger-connectivity-proof"},"Ledger connectivity proof"),(0,o.kt)("p",null,"Proof generation:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Alice is provided with a receipt (block header) from Bob who claim\u05d3 that some block is part of the ledger."),(0,o.kt)("li",{parentName:"ol"},"Alice requests from the server the header of the last block in the ledger, without revealing to the server which block she wants to validate. ",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"She can store the genesis block a-priori or request it as well."))),(0,o.kt)("li",{parentName:"ol"},"Alice requests the shortest path in the skip list from the block she validates to the genesis block."),(0,o.kt)("li",{parentName:"ol"},"Alice requests the shortest path from the last block of the ledger (2) to the block she validates"),(0,o.kt)("li",{parentName:"ol"},"Alice validates all a-priori known headers - genesis, block, last - in both paths and concatenates both paths; the result is the block proof.")),(0,o.kt)("p",null,"To check the proof validity for each block header in the proof starting from the genesis block, Alice executes the following steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"She calculates the block header hash."),(0,o.kt)("li",{parentName:"ol"},"If the calculated hash is in the next block header skip-list hash list, continue."),(0,o.kt)("li",{parentName:"ol"},"If not, fail.")),(0,o.kt)("p",null,"Optimization - because the result of each call to ",(0,o.kt)("inlineCode",{parentName:"p"},"Commit()")," is a transaction receipt containing a block header, the user can use this header if it has a higher block number than the block he wants to validate, thus avoiding the need to ask the server for the last block."),(0,o.kt)("p",null,"Please note that the algorithm above allows the user to build proofs from multiple blocks.\nFor example, proof for blocks 3 and 5 will include (8, 6, 5, 4, 3, 2, 0). It is useful while validating specific value history."),(0,o.kt)("p",null,"The above algorithm is used as the first step of the ",(0,o.kt)("a",{parentName:"p",href:"#transaction-existence-proof"},"transaction proof"),"/",(0,o.kt)("a",{parentName:"p",href:"#state-proof"},"state proof")," to prove that block(s) is/are part of the ledger."),(0,o.kt)("h4",{id:"transaction-existence-proof"},"Transaction existence proof"),(0,o.kt)("p",null,"Here is a detailed explanation of the transaction existence proof, based on data stored during the tx commit."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Alice submits a tx and in the future should be able to prove its existence:"),(0,o.kt)("li",{parentName:"ul"},"During the transaction commit, ",(0,o.kt)("inlineCode",{parentName:"li"},"TxReceipt")," containing the block header is returned as proof.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The transaction content and ",(0,o.kt)("inlineCode",{parentName:"li"},"TxReceipt")," are stored by Alice to use as proof to other users in the future."))),(0,o.kt)("li",{parentName:"ul"},"At some point in the future, Alice needs to prove (to Bob) that tx is part of the ledger, using the proof stored since the tx commit.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Alice provides Bob with ",(0,o.kt)("inlineCode",{parentName:"li"},"TxReceipt"),", signed by the server, and the transaction content, signed by Alice."),(0,o.kt)("li",{parentName:"ul"},"First, Bob checks ledger connectivity and that the block header in ",(0,o.kt)("inlineCode",{parentName:"li"},"TxReceipt")," is part of the ledger, as described ",(0,o.kt)("a",{parentName:"li",href:"#ledger-connectivity-proof"},"here"),"."),(0,o.kt)("li",{parentName:"ul"},"Second, Bob calls ",(0,o.kt)("inlineCode",{parentName:"li"},"GetTxProof()")," for the tx path in the block Merkle tree and the tx content already provided by Alice."),(0,o.kt)("li",{parentName:"ul"},"Bob validates the proof using the tx hash and Merkle root stored in the block header. For more details, see ",(0,o.kt)("a",{parentName:"li",href:"../../architecture-and-design/tx-merkle-tree#merkle-tree-proof-example"},"here"),". ")))),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"tx_proof",src:a(2748).Z})),(0,o.kt)("h4",{id:"state-proof"},"State proof"),(0,o.kt)("p",null,"Here is a detailed explanation of the historical state proof, based on data stored in Merkle-Patricia Trie."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Alice wants to get cryptographic proof from the server that that key ",(0,o.kt)("inlineCode",{parentName:"li"},"K")," was associated with value ",(0,o.kt)("inlineCode",{parentName:"li"},"X")," at the end of block ",(0,o.kt)("inlineCode",{parentName:"li"},"N"),"."),(0,o.kt)("li",{parentName:"ul"},"Alice asks the server to ",(0,o.kt)("inlineCode",{parentName:"li"},"BlockHeader")," for block ",(0,o.kt)("inlineCode",{parentName:"li"},"N"),"."),(0,o.kt)("li",{parentName:"ul"},"As described ",(0,o.kt)("a",{parentName:"li",href:"#ledger-connectivity-proof"},"here"),", Alice checks ledger connectivity and that the block header ",(0,o.kt)("inlineCode",{parentName:"li"},"N")," is part of the ledger."),(0,o.kt)("li",{parentName:"ul"},"Alice calls to ",(0,o.kt)("inlineCode",{parentName:"li"},"GetDataProof()")," and verifies it:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Calculates hash of ",(0,o.kt)("inlineCode",{parentName:"li"},"<db, key, value>")," tuple by calling ",(0,o.kt)("inlineCode",{parentName:"li"},"ConstructCompositeKey")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"CalculateKeyValueHash")),(0,o.kt)("li",{parentName:"ul"},"Call to ",(0,o.kt)("inlineCode",{parentName:"li"},"proof.Verify()"))))),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"state_proof",src:a(6264).Z})))}p.isMDXComponent=!0},6264:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/StateProof-5dbae9f8a9b98bc991eeb1328b26f637.png"},2748:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/TxProof-a82baa6b34df458bb7739d8bbd06497c.png"}}]);