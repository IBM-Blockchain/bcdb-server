// Code generated by protoc-gen-go. DO NOT EDIT.
// source: configuration.proto

package types

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Privilege_Access int32

const (
	Privilege_Read      Privilege_Access = 0
	Privilege_ReadWrite Privilege_Access = 1
)

var Privilege_Access_name = map[int32]string{
	0: "Read",
	1: "ReadWrite",
}

var Privilege_Access_value = map[string]int32{
	"Read":      0,
	"ReadWrite": 1,
}

func (x Privilege_Access) String() string {
	return proto.EnumName(Privilege_Access_name, int32(x))
}

func (Privilege_Access) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{9, 0}
}

// ClusterConfig holds the shared configuration of a blockchain database cluster.
// This includes:
// - a set of nodes that server client requests,
// - a set of admins,
// - the certificate authority configuration, including root and intermediate certificates, and
// - the consensus configuration.
//
// This part of the configuration is replicated and is common to all nodes.
// After the initial bootstrap, this part of the configuration can change only through configuration transactions.
type ClusterConfig struct {
	// The set of nodes that serve client requests, as they are known to clients.
	Nodes []*NodeConfig `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// The set of database administrators.
	Admins []*Admin `protobuf:"bytes,2,rep,name=admins,proto3" json:"admins,omitempty"`
	// The x509 certificates of the root and intermediate certificate authorities that issued all the certificates used
	// for client facing communication, including the client certificates and the server certificates for signing
	// transactions and blocks.
	CertAuthConfig *CAConfig `protobuf:"bytes,3,opt,name=cert_auth_config,json=certAuthConfig,proto3" json:"cert_auth_config,omitempty"`
	// The consensus configuration.
	ConsensusConfig      *ConsensusConfig `protobuf:"bytes,4,opt,name=consensus_config,json=consensusConfig,proto3" json:"consensus_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ClusterConfig) Reset()         { *m = ClusterConfig{} }
func (m *ClusterConfig) String() string { return proto.CompactTextString(m) }
func (*ClusterConfig) ProtoMessage()    {}
func (*ClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{0}
}

func (m *ClusterConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterConfig.Unmarshal(m, b)
}
func (m *ClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterConfig.Marshal(b, m, deterministic)
}
func (m *ClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterConfig.Merge(m, src)
}
func (m *ClusterConfig) XXX_Size() int {
	return xxx_messageInfo_ClusterConfig.Size(m)
}
func (m *ClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterConfig proto.InternalMessageInfo

func (m *ClusterConfig) GetNodes() []*NodeConfig {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ClusterConfig) GetAdmins() []*Admin {
	if m != nil {
		return m.Admins
	}
	return nil
}

func (m *ClusterConfig) GetCertAuthConfig() *CAConfig {
	if m != nil {
		return m.CertAuthConfig
	}
	return nil
}

func (m *ClusterConfig) GetConsensusConfig() *ConsensusConfig {
	if m != nil {
		return m.ConsensusConfig
	}
	return nil
}

// NodeConfig holds the information about a database node in the cluster.
// This information is exposed to the clients.
// The address and port (see below) define the HTTP/REST endpoint that clients connect to,
// and must be reachable by clients that submit requests to the database.
//
// TODO: change the name NodeConfig to Node once the existing message Node is renamed to something else.
type NodeConfig struct {
	// A unique identifier for the node within the cluster.
	// TODO define and enforce the characters that can be used for this field. Should be something that complies with file names.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The host name or IP address of the HTTP/REST endpoint served by this node.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// The port of the HTTP/REST endpoint served by this node.
	Port uint32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// The x509 certificate used by this node to authenticate its communication with clients.
	// This certificate corresponds to the private key the server uses to sign blocks and transaction responses.
	Certificate          []byte   `protobuf:"bytes,4,opt,name=certificate,proto3" json:"certificate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeConfig) Reset()         { *m = NodeConfig{} }
func (m *NodeConfig) String() string { return proto.CompactTextString(m) }
func (*NodeConfig) ProtoMessage()    {}
func (*NodeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{1}
}

func (m *NodeConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeConfig.Unmarshal(m, b)
}
func (m *NodeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeConfig.Marshal(b, m, deterministic)
}
func (m *NodeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfig.Merge(m, src)
}
func (m *NodeConfig) XXX_Size() int {
	return xxx_messageInfo_NodeConfig.Size(m)
}
func (m *NodeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfig proto.InternalMessageInfo

func (m *NodeConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeConfig) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NodeConfig) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *NodeConfig) GetCertificate() []byte {
	if m != nil {
		return m.Certificate
	}
	return nil
}

// Admin holds the id and certificate of a cluster administrator.
type Admin struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Certificate          []byte   `protobuf:"bytes,2,opt,name=certificate,proto3" json:"certificate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Admin) Reset()         { *m = Admin{} }
func (m *Admin) String() string { return proto.CompactTextString(m) }
func (*Admin) ProtoMessage()    {}
func (*Admin) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{2}
}

func (m *Admin) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Admin.Unmarshal(m, b)
}
func (m *Admin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Admin.Marshal(b, m, deterministic)
}
func (m *Admin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Admin.Merge(m, src)
}
func (m *Admin) XXX_Size() int {
	return xxx_messageInfo_Admin.Size(m)
}
func (m *Admin) XXX_DiscardUnknown() {
	xxx_messageInfo_Admin.DiscardUnknown(m)
}

var xxx_messageInfo_Admin proto.InternalMessageInfo

func (m *Admin) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Admin) GetCertificate() []byte {
	if m != nil {
		return m.Certificate
	}
	return nil
}

type CAConfig struct {
	Roots                [][]byte `protobuf:"bytes,1,rep,name=roots,proto3" json:"roots,omitempty"`
	Intermediates        [][]byte `protobuf:"bytes,2,rep,name=intermediates,proto3" json:"intermediates,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CAConfig) Reset()         { *m = CAConfig{} }
func (m *CAConfig) String() string { return proto.CompactTextString(m) }
func (*CAConfig) ProtoMessage()    {}
func (*CAConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{3}
}

func (m *CAConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CAConfig.Unmarshal(m, b)
}
func (m *CAConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CAConfig.Marshal(b, m, deterministic)
}
func (m *CAConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CAConfig.Merge(m, src)
}
func (m *CAConfig) XXX_Size() int {
	return xxx_messageInfo_CAConfig.Size(m)
}
func (m *CAConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CAConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CAConfig proto.InternalMessageInfo

func (m *CAConfig) GetRoots() [][]byte {
	if m != nil {
		return m.Roots
	}
	return nil
}

func (m *CAConfig) GetIntermediates() [][]byte {
	if m != nil {
		return m.Intermediates
	}
	return nil
}

// The definitions of the clustered consensus algorithm, members, and parameters.
type ConsensusConfig struct {
	// The consensus algorithm, currently only "raft" is supported.
	Algorithm string `protobuf:"bytes,1,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	// Peers that take part in consensus.
	Members []*PeerConfig `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	// Peers that are allowed to connect and fetch the ledger from members, but do not take part in consensus.
	Observers []*PeerConfig `protobuf:"bytes,3,rep,name=observers,proto3" json:"observers,omitempty"`
	// Raft protocol parameters.
	RaftConfig           *RaftConfig `protobuf:"bytes,4,opt,name=raft_config,json=raftConfig,proto3" json:"raft_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ConsensusConfig) Reset()         { *m = ConsensusConfig{} }
func (m *ConsensusConfig) String() string { return proto.CompactTextString(m) }
func (*ConsensusConfig) ProtoMessage()    {}
func (*ConsensusConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{4}
}

func (m *ConsensusConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConsensusConfig.Unmarshal(m, b)
}
func (m *ConsensusConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConsensusConfig.Marshal(b, m, deterministic)
}
func (m *ConsensusConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusConfig.Merge(m, src)
}
func (m *ConsensusConfig) XXX_Size() int {
	return xxx_messageInfo_ConsensusConfig.Size(m)
}
func (m *ConsensusConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusConfig proto.InternalMessageInfo

func (m *ConsensusConfig) GetAlgorithm() string {
	if m != nil {
		return m.Algorithm
	}
	return ""
}

func (m *ConsensusConfig) GetMembers() []*PeerConfig {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *ConsensusConfig) GetObservers() []*PeerConfig {
	if m != nil {
		return m.Observers
	}
	return nil
}

func (m *ConsensusConfig) GetRaftConfig() *RaftConfig {
	if m != nil {
		return m.RaftConfig
	}
	return nil
}

// PeerConfig defines a server that takes part in consensus, or an observer.
type PeerConfig struct {
	// The node ID correlates the peer definition here with the NodeConfig.ID field.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Raft ID must be >0 for members, or =0 for observers.
	RaftId uint64 `protobuf:"varint,2,opt,name=raft_id,json=raftId,proto3" json:"raft_id,omitempty"`
	// The host name or IP address that is used by other peers to connect to this peer.
	PeerHost string `protobuf:"bytes,3,opt,name=peer_host,json=peerHost,proto3" json:"peer_host,omitempty"`
	// The port that is used by other peers to connect to this peer.
	PeerPort             uint32   `protobuf:"varint,4,opt,name=peer_port,json=peerPort,proto3" json:"peer_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerConfig) Reset()         { *m = PeerConfig{} }
func (m *PeerConfig) String() string { return proto.CompactTextString(m) }
func (*PeerConfig) ProtoMessage()    {}
func (*PeerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{5}
}

func (m *PeerConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PeerConfig.Unmarshal(m, b)
}
func (m *PeerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PeerConfig.Marshal(b, m, deterministic)
}
func (m *PeerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerConfig.Merge(m, src)
}
func (m *PeerConfig) XXX_Size() int {
	return xxx_messageInfo_PeerConfig.Size(m)
}
func (m *PeerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PeerConfig proto.InternalMessageInfo

func (m *PeerConfig) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *PeerConfig) GetRaftId() uint64 {
	if m != nil {
		return m.RaftId
	}
	return 0
}

func (m *PeerConfig) GetPeerHost() string {
	if m != nil {
		return m.PeerHost
	}
	return ""
}

func (m *PeerConfig) GetPeerPort() uint32 {
	if m != nil {
		return m.PeerPort
	}
	return 0
}

type RaftConfig struct {
	// Time interval between two Node.Tick invocations, e.g. 100ms.
	// Any duration string parsable by ParseDuration():
	// https://golang.org/pkg/time/#ParseDuration
	TickInterval string `protobuf:"bytes,1,opt,name=tick_interval,json=tickInterval,proto3" json:"tick_interval,omitempty"`
	// The number of Node.Tick invocations that must pass  between elections.
	// That is, if a follower does not receive any
	// message from the leader of current term before ElectionTick has
	// elapsed, it will become candidate and start an election.
	// electionTicks must be greater than heartbeatTicks.
	ElectionTicks uint32 `protobuf:"varint,2,opt,name=election_ticks,json=electionTicks,proto3" json:"election_ticks,omitempty"`
	// The number of Node.Tick invocations that must
	// pass between heartbeats. That is, a leader sends heartbeat
	// messages to maintain its leadership every HeartbeatTick ticks.
	HeartbeatTicks uint32 `protobuf:"varint,3,opt,name=heartbeat_ticks,json=heartbeatTicks,proto3" json:"heartbeat_ticks,omitempty"`
	// Limits the max number of in-flight blocks (i.e. Raft messages).
	MaxInflightBlocks uint32 `protobuf:"varint,4,opt,name=max_inflight_blocks,json=maxInflightBlocks,proto3" json:"max_inflight_blocks,omitempty"`
	// Take a snapshot when cumulative data since last snapshot exceeds a certain size in bytes.
	SnapshotIntervalSize uint64   `protobuf:"varint,5,opt,name=snapshot_interval_size,json=snapshotIntervalSize,proto3" json:"snapshot_interval_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftConfig) Reset()         { *m = RaftConfig{} }
func (m *RaftConfig) String() string { return proto.CompactTextString(m) }
func (*RaftConfig) ProtoMessage()    {}
func (*RaftConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{6}
}

func (m *RaftConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RaftConfig.Unmarshal(m, b)
}
func (m *RaftConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RaftConfig.Marshal(b, m, deterministic)
}
func (m *RaftConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftConfig.Merge(m, src)
}
func (m *RaftConfig) XXX_Size() int {
	return xxx_messageInfo_RaftConfig.Size(m)
}
func (m *RaftConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RaftConfig proto.InternalMessageInfo

func (m *RaftConfig) GetTickInterval() string {
	if m != nil {
		return m.TickInterval
	}
	return ""
}

func (m *RaftConfig) GetElectionTicks() uint32 {
	if m != nil {
		return m.ElectionTicks
	}
	return 0
}

func (m *RaftConfig) GetHeartbeatTicks() uint32 {
	if m != nil {
		return m.HeartbeatTicks
	}
	return 0
}

func (m *RaftConfig) GetMaxInflightBlocks() uint32 {
	if m != nil {
		return m.MaxInflightBlocks
	}
	return 0
}

func (m *RaftConfig) GetSnapshotIntervalSize() uint64 {
	if m != nil {
		return m.SnapshotIntervalSize
	}
	return 0
}

// Database configuration. Stores default read/write ACLs
// Stored as value in _dbs system database under key 'name'
type DatabaseConfig struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ReadAccessUsers      []string `protobuf:"bytes,2,rep,name=read_access_users,json=readAccessUsers,proto3" json:"read_access_users,omitempty"`
	WriteAccessUsers     []string `protobuf:"bytes,3,rep,name=write_access_users,json=writeAccessUsers,proto3" json:"write_access_users,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseConfig) Reset()         { *m = DatabaseConfig{} }
func (m *DatabaseConfig) String() string { return proto.CompactTextString(m) }
func (*DatabaseConfig) ProtoMessage()    {}
func (*DatabaseConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{7}
}

func (m *DatabaseConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabaseConfig.Unmarshal(m, b)
}
func (m *DatabaseConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabaseConfig.Marshal(b, m, deterministic)
}
func (m *DatabaseConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseConfig.Merge(m, src)
}
func (m *DatabaseConfig) XXX_Size() int {
	return xxx_messageInfo_DatabaseConfig.Size(m)
}
func (m *DatabaseConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseConfig proto.InternalMessageInfo

func (m *DatabaseConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabaseConfig) GetReadAccessUsers() []string {
	if m != nil {
		return m.ReadAccessUsers
	}
	return nil
}

func (m *DatabaseConfig) GetWriteAccessUsers() []string {
	if m != nil {
		return m.WriteAccessUsers
	}
	return nil
}

// User holds userID, certificate, privilege the user has,
// and groups the user belong to.
type User struct {
	Id                   string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Certificate          []byte     `protobuf:"bytes,2,opt,name=certificate,proto3" json:"certificate,omitempty"`
	Privilege            *Privilege `protobuf:"bytes,3,opt,name=privilege,proto3" json:"privilege,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{8}
}

func (m *User) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_User.Unmarshal(m, b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_User.Marshal(b, m, deterministic)
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return xxx_messageInfo_User.Size(m)
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetCertificate() []byte {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *User) GetPrivilege() *Privilege {
	if m != nil {
		return m.Privilege
	}
	return nil
}

// Privilege holds user/group privilege information such as
// a list of databases to which the read is allowed, a list of
// databases to which the write is allowed, bools to indicate
// where the db manipulation such as DB creation/deletion and
// user manipulation such as add/update/delete are allowed.
type Privilege struct {
	DbPermission map[string]Privilege_Access `protobuf:"bytes,1,rep,name=db_permission,json=dbPermission,proto3" json:"db_permission,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=types.Privilege_Access"`
	// admin has privileges to submit a user administration transaction,
	// cluster configuration transaction, and database administration
	// transaction. Further, admin has permission to read-write states
	// from any database provided that the state has no ACL defined. If
	// a state has a read and write ACL, the admin can read or write to
	// the state only if the admin is listed in the read or write ACL list.
	Admin                bool     `protobuf:"varint,2,opt,name=admin,proto3" json:"admin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Privilege) Reset()         { *m = Privilege{} }
func (m *Privilege) String() string { return proto.CompactTextString(m) }
func (*Privilege) ProtoMessage()    {}
func (*Privilege) Descriptor() ([]byte, []int) {
	return fileDescriptor_415c9e57263f32ab, []int{9}
}

func (m *Privilege) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Privilege.Unmarshal(m, b)
}
func (m *Privilege) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Privilege.Marshal(b, m, deterministic)
}
func (m *Privilege) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Privilege.Merge(m, src)
}
func (m *Privilege) XXX_Size() int {
	return xxx_messageInfo_Privilege.Size(m)
}
func (m *Privilege) XXX_DiscardUnknown() {
	xxx_messageInfo_Privilege.DiscardUnknown(m)
}

var xxx_messageInfo_Privilege proto.InternalMessageInfo

func (m *Privilege) GetDbPermission() map[string]Privilege_Access {
	if m != nil {
		return m.DbPermission
	}
	return nil
}

func (m *Privilege) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

func init() {
	proto.RegisterEnum("types.Privilege_Access", Privilege_Access_name, Privilege_Access_value)
	proto.RegisterType((*ClusterConfig)(nil), "types.ClusterConfig")
	proto.RegisterType((*NodeConfig)(nil), "types.NodeConfig")
	proto.RegisterType((*Admin)(nil), "types.Admin")
	proto.RegisterType((*CAConfig)(nil), "types.CAConfig")
	proto.RegisterType((*ConsensusConfig)(nil), "types.ConsensusConfig")
	proto.RegisterType((*PeerConfig)(nil), "types.PeerConfig")
	proto.RegisterType((*RaftConfig)(nil), "types.RaftConfig")
	proto.RegisterType((*DatabaseConfig)(nil), "types.DatabaseConfig")
	proto.RegisterType((*User)(nil), "types.User")
	proto.RegisterType((*Privilege)(nil), "types.Privilege")
	proto.RegisterMapType((map[string]Privilege_Access)(nil), "types.Privilege.DbPermissionEntry")
}

func init() { proto.RegisterFile("configuration.proto", fileDescriptor_415c9e57263f32ab) }

var fileDescriptor_415c9e57263f32ab = []byte{
	// 784 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x4b, 0x6f, 0xe4, 0x44,
	0x10, 0xc6, 0xf3, 0x4a, 0x5c, 0x99, 0x57, 0x7a, 0x57, 0xbb, 0x23, 0xe0, 0x10, 0xcc, 0xa2, 0x8d,
	0x80, 0xcc, 0x48, 0xc3, 0x1e, 0x58, 0x6e, 0xb3, 0x59, 0x1e, 0xb9, 0xa0, 0xa8, 0x01, 0x81, 0xb8,
	0x58, 0x6d, 0xbb, 0x66, 0xdc, 0x8a, 0xed, 0xb6, 0xba, 0x7b, 0x42, 0x92, 0x03, 0xff, 0x8d, 0xff,
	0xc1, 0x9d, 0xbf, 0x81, 0xfa, 0x35, 0x93, 0x87, 0x38, 0x70, 0xab, 0xfe, 0xbe, 0xaf, 0xda, 0x5f,
	0x57, 0x55, 0xb7, 0xe1, 0x59, 0x2e, 0x9a, 0x35, 0xdf, 0x6c, 0x25, 0xd3, 0x5c, 0x34, 0xf3, 0x56,
	0x0a, 0x2d, 0x48, 0x5f, 0xdf, 0xb6, 0xa8, 0x92, 0xbf, 0x23, 0x18, 0x9d, 0x57, 0x5b, 0xa5, 0x51,
	0x9e, 0x5b, 0x15, 0x79, 0x0d, 0xfd, 0x46, 0x14, 0xa8, 0x66, 0xd1, 0x49, 0xf7, 0xf4, 0x68, 0x79,
	0x3c, 0xb7, 0xc2, 0xf9, 0x8f, 0xa2, 0x40, 0xa7, 0xa0, 0x8e, 0x27, 0xaf, 0x60, 0xc0, 0x8a, 0x9a,
	0x37, 0x6a, 0xd6, 0xb1, 0xca, 0xa1, 0x57, 0xae, 0x0c, 0x48, 0x3d, 0x47, 0xde, 0xc2, 0x34, 0x47,
	0xa9, 0x53, 0xb6, 0xd5, 0x65, 0xea, 0x8c, 0xcc, 0xba, 0x27, 0xd1, 0xe9, 0xd1, 0x72, 0xe2, 0xf5,
	0xe7, 0x2b, 0xbf, 0xef, 0xd8, 0x08, 0x57, 0x5b, 0x5d, 0x7a, 0x27, 0x2b, 0x98, 0xe6, 0xa2, 0x51,
	0xd8, 0xa8, 0xad, 0x0a, 0xa9, 0x3d, 0x9b, 0xfa, 0x22, 0xa4, 0x06, 0xda, 0xef, 0x30, 0xc9, 0x1f,
	0x02, 0x49, 0x05, 0xb0, 0x37, 0x4e, 0xc6, 0xd0, 0xe1, 0xc5, 0x2c, 0x3a, 0x89, 0x4e, 0x63, 0xda,
	0xe1, 0x05, 0x99, 0xc1, 0x01, 0x2b, 0x0a, 0x89, 0xca, 0x1c, 0xc1, 0x80, 0x61, 0x49, 0x08, 0xf4,
	0x5a, 0x21, 0xb5, 0x75, 0x3a, 0xa2, 0x36, 0x26, 0x27, 0x70, 0x64, 0x0c, 0xf2, 0x35, 0xcf, 0x99,
	0x46, 0xeb, 0x64, 0x48, 0xef, 0x43, 0xc9, 0x5b, 0xe8, 0xdb, 0xc3, 0x3f, 0xf9, 0xd0, 0xa3, 0xd4,
	0xce, 0xd3, 0xd4, 0xef, 0xe0, 0x30, 0xd4, 0x81, 0x3c, 0x87, 0xbe, 0x14, 0x42, 0xbb, 0x0e, 0x0c,
	0xa9, 0x5b, 0x90, 0x57, 0x30, 0xe2, 0x8d, 0x46, 0x59, 0x63, 0xc1, 0x99, 0x46, 0x57, 0xf5, 0x21,
	0x7d, 0x08, 0x26, 0x7f, 0x45, 0x30, 0x79, 0x54, 0x15, 0xf2, 0x31, 0xc4, 0xac, 0xda, 0x08, 0xc9,
	0x75, 0x59, 0x7b, 0x53, 0x7b, 0x80, 0x7c, 0x01, 0x07, 0x35, 0xd6, 0x19, 0xca, 0xd0, 0xc7, 0xd0,
	0xf1, 0x4b, 0x0c, 0x33, 0x41, 0x83, 0x82, 0x2c, 0x20, 0x16, 0x99, 0x42, 0x79, 0x6d, 0xe4, 0xdd,
	0xff, 0x92, 0xef, 0x35, 0x64, 0x09, 0x47, 0x92, 0xad, 0xf5, 0xc3, 0xf6, 0x85, 0x14, 0xca, 0xd6,
	0xda, 0xa7, 0x80, 0xdc, 0xc5, 0xc9, 0x0d, 0xc0, 0x7e, 0x33, 0xf2, 0x12, 0x0e, 0xcc, 0xbc, 0xa5,
	0xbb, 0x82, 0x0e, 0xcc, 0xf2, 0xa2, 0x30, 0x84, 0xdd, 0x9a, 0x17, 0xb6, 0xa0, 0x3d, 0x3a, 0x30,
	0xcb, 0x8b, 0x82, 0x7c, 0x04, 0x71, 0x8b, 0x28, 0xd3, 0x52, 0x28, 0xd7, 0xc1, 0x98, 0x1e, 0x1a,
	0xe0, 0x07, 0xa1, 0xf4, 0x8e, 0xb4, 0xed, 0xed, 0xd9, 0xf6, 0x5a, 0xf2, 0x52, 0x48, 0x9d, 0xfc,
	0x13, 0x01, 0xec, 0x4d, 0x91, 0x4f, 0x61, 0xa4, 0x79, 0x7e, 0x95, 0xda, 0x12, 0x5f, 0xb3, 0xca,
	0x1b, 0x18, 0x1a, 0xf0, 0xc2, 0x63, 0xe4, 0x33, 0x18, 0x63, 0x85, 0xb9, 0xb9, 0x5a, 0xa9, 0x21,
	0xdc, 0x2c, 0x8d, 0xe8, 0x28, 0xa0, 0x3f, 0x1b, 0x90, 0xbc, 0x86, 0x49, 0x89, 0x4c, 0xea, 0x0c,
	0x99, 0xf6, 0x3a, 0x37, 0x5c, 0xe3, 0x1d, 0xec, 0x84, 0x73, 0x78, 0x56, 0xb3, 0x9b, 0x94, 0x37,
	0xeb, 0x8a, 0x6f, 0x4a, 0x9d, 0x66, 0x95, 0x30, 0x62, 0x67, 0xf5, 0xb8, 0x66, 0x37, 0x17, 0x9e,
	0x79, 0x67, 0x09, 0xf2, 0x06, 0x5e, 0xa8, 0x86, 0xb5, 0xaa, 0x14, 0x7a, 0x67, 0x34, 0x55, 0xfc,
	0x0e, 0x67, 0x7d, 0x5b, 0x95, 0xe7, 0x81, 0x0d, 0x8e, 0x7f, 0xe2, 0x77, 0x98, 0xfc, 0x09, 0xe3,
	0xf7, 0x4c, 0xb3, 0x8c, 0xa9, 0x70, 0x39, 0x08, 0xf4, 0x1a, 0x56, 0xa3, 0x3f, 0xa3, 0x8d, 0xc9,
	0xe7, 0x70, 0x2c, 0x91, 0x15, 0x29, 0xcb, 0x73, 0x54, 0x2a, 0xdd, 0xaa, 0x30, 0x25, 0x31, 0x9d,
	0x18, 0x62, 0x65, 0xf1, 0x5f, 0x0c, 0x4c, 0xbe, 0x04, 0xf2, 0x87, 0xe4, 0x1a, 0x1f, 0x8a, 0xbb,
	0x56, 0x3c, 0xb5, 0xcc, 0x3d, 0x75, 0x52, 0x42, 0xcf, 0x04, 0xff, 0xff, 0xa6, 0x90, 0x39, 0xc4,
	0xad, 0xe4, 0xd7, 0xbc, 0xc2, 0x0d, 0xfa, 0x97, 0x64, 0x1a, 0x46, 0x30, 0xe0, 0x74, 0x2f, 0x31,
	0x3d, 0x8d, 0x77, 0x04, 0xf9, 0x1e, 0x46, 0x45, 0x96, 0xb6, 0x28, 0x6b, 0xae, 0x14, 0x17, 0x8d,
	0x7f, 0xe5, 0x92, 0xc7, 0x3b, 0xcc, 0xdf, 0x67, 0x97, 0x3b, 0xd1, 0xb7, 0x8d, 0x96, 0xb7, 0x74,
	0x58, 0xdc, 0x83, 0xcc, 0x25, 0xb5, 0x2f, 0x9c, 0xb5, 0x78, 0x48, 0xdd, 0xe2, 0xc3, 0xdf, 0xe0,
	0xf8, 0x49, 0x22, 0x99, 0x42, 0xf7, 0x0a, 0x6f, 0xfd, 0x21, 0x4d, 0x48, 0xce, 0xa0, 0x7f, 0xcd,
	0xaa, 0xad, 0x3b, 0xdf, 0x78, 0xf9, 0xf2, 0xc9, 0xd7, 0x5d, 0xa9, 0xa8, 0x53, 0x7d, 0xd3, 0xf9,
	0x3a, 0x4a, 0x3e, 0x81, 0x81, 0x03, 0xc9, 0x21, 0xf4, 0x28, 0xb2, 0x62, 0xfa, 0x01, 0x19, 0x41,
	0x6c, 0xa2, 0x5f, 0x4d, 0x71, 0xa7, 0xd1, 0xbb, 0x37, 0xbf, 0x2f, 0x37, 0x5c, 0x97, 0xdb, 0x6c,
	0x9e, 0x8b, 0x7a, 0x51, 0xde, 0xb6, 0x28, 0x2b, 0x2c, 0x36, 0x28, 0xcf, 0x2a, 0x96, 0xa9, 0x85,
	0x90, 0x5c, 0x34, 0x67, 0xee, 0x62, 0x2e, 0xda, 0xab, 0xcd, 0xc2, 0x7e, 0x34, 0x1b, 0xd8, 0xff,
	0xc1, 0x57, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x61, 0x6b, 0x98, 0x39, 0x26, 0x06, 0x00, 0x00,
}
